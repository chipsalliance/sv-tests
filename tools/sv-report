#!/usr/bin/env python3

from glob import glob
import argparse
import logging
import jinja2
import sys
import os
import re

parser = argparse.ArgumentParser()

logger_args = parser.add_mutually_exclusive_group()

logger_args.add_argument("-q", "--quiet",
                         action="store_true",
                         help="Disable all logs")

logger_args.add_argument("-v", "--verbose",
                         action="store_true",
                         help="Verbose logging")

parser.add_argument("-i", "--input",
                    help="Input database/LRM",
                    default="conf/lrm.conf")

parser.add_argument("-l", "--logs",
                    help="Directory with all the individual test results",
                    default="out/logs")

parser.add_argument("-t", "--template",
                    help="Path to the html report tepmplate",
                    default="conf/report-template.html")

parser.add_argument("-o", "--out",
                    help="Path to the html file with the report",
                    default="out/report.html")

# parse args
args = parser.parse_args()

# setup logger
logger = logging.getLogger()
logger.setLevel(logging.DEBUG)

ch = logging.StreamHandler()
ch.setFormatter(logging.Formatter('%(levelname)-8s| %(message)s'))
logger.addHandler(ch)

if args.quiet:
    logger.setLevel(logging.ERROR)
elif args.verbose:
    logger.setLevel(logging.DEBUG)
else:
    logger.setLevel(logging.INFO)

tag_usage = {}

# generate input database first
database = {}
try:
    with open(args.input) as f:
        for l in f:
            ls = l.strip()
            # skip lines with comments
            if re.search(r"^\s*#.*", ls) is not None:
                continue

            entry = ls.split("\t")

            if len(entry) < 2:
                raise KeyError("Invalid entry: " + ls)

            database[entry[0]] = "\t".join(entry[1:])
except KeyError as e:
    # TODO: exit on error/critical handler
    logger.critical("Unable to parse the database - " + str(e))
    sys.exit(1)

logger.info("Generating {} from log files in '{}'".format(args.out, args.logs))

for tag in database:
    tag_usage[tag] = 0

data = {}

for r in [os.path.dirname(r) for r in glob(args.logs + "/*/")]:
    r_name = os.path.basename(r)
    logger.debug("Found Runner: " + r_name)
    data[r_name] = {}

    # all tests info
    data[r_name]["tests"] = {}
    tests = data[r_name]["tests"]

    for t in glob(os.path.join(args.logs, r_name, "**/*.log"), recursive=True):
        t_id = t[len(args.logs) + 1:]
        logger.debug("Found log: " + t_id)

        tests[t_id] = {}

        test_tags = ["name", "tags", "should_fail", "rc",
                     "description", "files", "incdirs",
                     "top_module"]
        with open(t, "r") as f:
            try:
                for l in f:
                    tag = re.search(r"^([a-zA-Z_-]+):(.+)", l)

                    if tag is None:
                        raise KeyError("Could not find tags: {}"
                                       .format(", ".join(test_tags)))

                    param = tag.group(1).lower()
                    value = tag.group(2).strip()

                    if param in test_tags:
                        test_tags.remove(param)
                        tests[t_id][param] = value

                        if len(test_tags) == 0:
                            # found all tags
                            break
                    else:
                        logger.warning(
                                "Skipping unknown parameter: {} in {}"
                                .format(param, t))

            except Exception as e:
                logger.warning("Skipping {} on {}: {}"
                               .format(t, r_name, str(e)))
                del tests[t_id]
                continue

            f.seek(0)
            tests[t_id]["log"] = f.read()

        # check if test was skipped
        if t_id not in tests:
            continue

        # Initialize the tag-based side of the result dict
        data[r_name]["tags"] = {}
        tags = data[r_name]["tags"]

        for tag in database:
            tags[tag] = {}
            tags[tag]["status"] = []

        # generate tags summary
        for _, test in tests.items():
            # check if test has passed
            passed = True

            tool_should_fail = test["should_fail"] == "1"
            tool_failed = test["rc"] != "0"

            if int(test["rc"]) >= 126 or tool_should_fail != tool_failed:
                passed = False

            status = "test-" + ("passed" if passed else "failed")
            test["status"] = status

            if passed:
                logger.debug("{} passed {} in {}"
                             .format(r_name, test["tags"], test["name"]))
            else:
                logger.debug("{} failed {} in {}"
                             .format(r_name, test["tags"], test["name"]))

            for tag in test["tags"].split(" "):
                try:
                    tag_usage[tag] += 1
                    tags[tag]["status"].append(status)
                except KeyError:
                    logger.warning("Tag not present in the database: " + tag)
                    database[tag] = ''
                    tag_usage[tag] = 1
                    tags[tag] = {}
                    tags[tag]["status"] = [status]
                    continue

        for tag in tags:
            tags[tag]["passed-num"] = tags[tag]["status"].count("test-passed")

            if len(tags[tag]["status"]) == 0:
                tags[tag]["status"] = "test-na"
            elif all(tags[tag]["status"][0] == x for x in tags[tag]["status"]):
                tags[tag]["status"] = tags[tag]["status"][0]
            else:
                tags[tag]["status"] = "test-varied"

for tag in tag_usage:
    if tag_usage[tag] == 0:
        del database[tag]

try:
    for r in data:
        for tag in data[r]["tags"]:
            tag_handle = data[r]["tags"][tag]

            tag_handle["logs"] = {}

            for test in data[r]["tests"]:
                test_handle = data[r]["tests"][test]
                if tag in test_handle["tags"].split():
                    tag_handle["logs"][test] = {}
                    inner = tag_handle["logs"][test]
                    inner["log"] = test_handle["log"].replace("\n", "</br>")
                    inner["status"] = test_handle["status"]
                    inner["name"] = test_handle["name"]

    with open(args.template, "r") as f:
        report = jinja2.Template(f.read(),
                                 trim_blocks=True,
                                 lstrip_blocks=True)

    with open(args.out, 'w') as f:
        f.write(report.render(report=data, database=database))
except KeyError:
    logger.critical("Unable to generate report, not enough logs")
except Exception as e:
    logger.critical("Unable to generate report: " + str(e))
