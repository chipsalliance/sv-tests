# vim: noet tabstop=64
#
# input database for the report generator
# syntax:
# <TAG NAME><tab><TAG DESCRIPTION>[<tab><TAG URL>]
#
sanity	Various sanity checks
swerv	SweRV RISC-V core	https://github.com/chipsalliance/Cores-SweRV
ibex	Ibex RISC-V core	https://github.com/lowRISC/ibex
earlgrey	Lowrisc chip with Ibex core	https://github.com/lowRISC/opentitan
fx68k	FX68K m68k core	https://github.com/ijor/fx68k
yosys	Tests imported from Yosys	https://github.com/YosysHQ/yosys/tree/master/tests/hana
hdlconv	Tests imported from hdlConvertor	https://github.com/Nic30/hdlConvertor/tree/master/tests
utd-sv	Tests imported from utd-SystemVerilog	https://github.com/SymbiFlow/sv-tests/tree/master/third_party/tests/utd-sv
uvm	Tests imported from UVM	https://github.com/SymbiFlow/uvm
uvm-req	UVM Prerequisites
uvm-assertions	UVM tests using assertions
uvm-scoreboards	uvm_scoreboard examples
uvm-agents	uvm_agent examples
uvm-classes	Particular UVM classes
basejump	Tests imported from Basejump STL	https://github.com/bespoke-silicon-group/basejump_stl
ariane	Ariane RISC-V core	https://github.com/openhwgroup/cva6
scr1	SCR1 RISC-V core	https://github.com/syntacore/scr1
taiga	Taiga RISC-V core	https://gitlab.com/sfu-rcl/Taiga
black-parrot	BlackParrot RISC-V core	https://github.com/black-parrot/black-parrot
rsd	RSD RISC-V core	https://github.com/rsd-devel/rsd
ivtest	Tests imported from ivtest	https://github.com/steveicarus/ivtest
TNoC	NoC router and fabric	https://github.com/taichi-ishitani/tnoc
5	Lexical conventions
5.1	General
5.2	Lexical tokens
5.3	White space
5.4	Comments
5.5	Operators
5.6	Identifiers, keywords, and system names
5.6.1	Escaped identifiers
5.6.2	Keywords
5.6.3	System tasks and system functions
5.6.4	Compiler directives
5.7	Numbers
5.7.1	Integer literal constants
5.7.2	Real literal constants
5.8	Time literals
5.9	String literals
5.9.1	Special characters in strings
5.10	Structure literals
5.11	Array literals
5.12	Attributes
5.13	Built-in methods
6	Data types
6.1	General
6.2	Data types and data objects
6.3	Value set
6.3.1	Logic values
6.3.2	Strengths
6.3.2.1	Charge strength
6.3.2.2	Drive strength
6.4	Singular and aggregate types
6.5	Nets and variables
6.6	Net types
6.6.1	Wire and tri nets
6.6.2	Unresolved nets
6.6.3	Wired nets
6.6.4	Trireg net
6.6.4.1	Capacitive networks
6.6.4.2	Ideal capacitive state and charge decay
6.6.5	Tri0 and tri1 nets
6.6.6	Supply nets
6.6.7	User-defined nettypes
6.6.8	Generic interconnect
6.7	Net declarations
6.7.1	Net declarations with built-in net types
6.7.2	Net declarations with user-defined nettypes
6.7.3	Initialization of nets with user-defined nettypes
6.8	Variable declarations
6.9	Vector declarations
6.9.1	Specifying vectors
6.9.2	Vector net accessibility
6.10	Implicit declarations
6.11	Integer data types
6.11.1	Integral types
6.11.2	2-state (two-value) and 4-state (four-value) data types
6.11.3	Signed and unsigned integer types
6.12	Real, shortreal, and realtime data types
6.12.1	Operators and real numbers
6.12.2	Conversion
6.13	Void data type
6.14	Chandle data type
6.15	Class
6.16	String data type
6.16.1	Len()
6.16.2	Putc()
6.16.3	Getc()
6.16.4	Toupper()
6.16.5	Tolower()
6.16.6	Compare()
6.16.7	Icompare()
6.16.8	Substr()
6.16.9	Atoi(), atohex(), atooct(), atobin()
6.16.10	Atoreal()
6.16.11	Itoa()
6.16.12	Hextoa()
6.16.13	Octtoa()
6.16.14	Bintoa()
6.16.15	Realtoa()
6.17	Event data type
6.18	User-defined types
6.19	Enumerations
6.19.1	Defining new data types as enumerated types
6.19.2	Enumerated type ranges
6.19.3	Type checking
6.19.4	Enumerated types in numerical expressions
6.19.5	Enumerated type methods
6.19.5.1	First()
6.19.5.2	Last()
6.19.5.3	Next()
6.19.5.4	Prev()
6.19.5.5	Num()
6.19.5.6	Name()
6.19.5.7	Using enumerated type methods
6.20	Constants
6.20.1	Parameter declaration syntax
6.20.2	Value parameters
6.20.2.1	$ as a parameter value
6.20.3	Type parameters
6.20.4	Local parameters (localparam)
6.20.5	Specify parameters
6.20.6	Const constants
6.21	Scope and lifetime
6.22	Type compatibility
6.22.1	Matching types
6.22.2	Equivalent types
6.22.3	Assignment compatible
6.22.4	Cast compatible
6.22.5	Type incompatible
6.22.6	Matching nettypes
6.23	Type operator
6.24	Casting
6.24.1	Cast operator
6.24.2	$cast dynamic casting
6.24.3	Bit-stream casting
6.25	Parameterized data types
7	Aggregate data types
7.1	General
7.2	Structures
7.2.1	Packed structures
7.2.2	Assigning to structures
7.3	Unions
7.3.1	Packed unions
7.3.2	Tagged unions
7.4	Packed and unpacked arrays
7.4.1	Packed arrays
7.4.2	Unpacked arrays
7.4.3	Operations on arrays
7.4.4	Memories
7.4.5	Multidimensional arrays
7.4.6	Indexing and slicing of arrays
7.5	Dynamic arrays
7.5.1	New[ ]
7.5.2	Size()
7.5.3	Delete()
7.6	Array assignments
7.7	Arrays as arguments to subroutines
7.8	Associative arrays
7.8.1	Wildcard index type
7.8.2	String index
7.8.3	Class index
7.8.4	Integral index
7.8.5	Other user-defined types
7.8.6	Accessing invalid indices
7.8.7	Allocating associative array elements
7.9	Associative array methods
7.9.1	Num() and size()
7.9.2	Delete()
7.9.3	Exists()
7.9.4	First()
7.9.5	Last()
7.9.6	Next()
7.9.7	Prev()
7.9.8	Arguments to traversal methods
7.9.9	Associative array assignment
7.9.10	Associative array arguments
7.9.11	Associative array literals
7.10	Queues
7.10.1	Queue operators
7.10.2	Queue methods
7.10.2.1	Size()
7.10.2.2	Insert()
7.10.2.3	Delete()
7.10.2.4	Pop_front()
7.10.2.5	Pop_back()
7.10.2.6	Push_front()
7.10.2.7	Push_back()
7.10.3	Persistence of references to elements of a queue
7.10.4	Updating a queue using assignment and unpacked array concatenation
7.10.5	Bounded queues
7.11	Array querying functions
7.12	Array manipulation methods
7.12.1	Array locator methods
7.12.2	Array ordering methods
7.12.3	Array reduction methods
7.12.4	Iterator index querying
8	Classes
8.1	General
8.2	Overview
8.3	Syntax
8.4	Objects (class instance)
8.5	Object properties and object parameter data
8.6	Object methods
8.7	Constructors
8.8	Typed constructor calls
8.9	Static class properties
8.10	Static methods
8.11	This
8.12	Assignment, renaming, and copying
8.13	Inheritance and subclasses
8.14	Overridden members
8.15	Super
8.16	Casting
8.17	Chaining constructors
8.18	Data hiding and encapsulation
8.19	Constant class properties
8.20	Virtual methods
8.21	Abstract classes and pure virtual methods
8.22	Polymorphism: dynamic method lookup
8.23	Class scope resolution operator ::
8.24	Out-of-block declarations
8.25	Parameterized classes
8.25.1	Class scope resolution operator for parameterized classes
8.26	Interface classes
8.26.1	Interface class syntax
8.26.2	Extends versus implements
8.26.3	Type access
8.26.4	Type usage restrictions
8.26.5	Casting and object reference assignment
8.26.6	Name conflicts and resolution
8.26.6.1	Method name conflict resolution
8.26.6.2	Parameter and type declaration inheritance conflicts and resolution
8.26.6.3	Diamond relationship
8.26.7	Partial implementation
8.26.8	Method default argument values
8.26.9	Constraint blocks, covergroups, and randomization
8.27	Typedef class
8.28	Classes and structures
8.29	Memory management
9	Processes
9.1	General
9.2	Structured procedures
9.2.1	Initial procedures
9.2.2	Always procedures
9.2.2.1	General purpose always procedure
9.2.2.2	Combinational logic always_comb procedure
9.2.2.2.1	Implicit always_comb sensitivities
9.2.2.2.2	always_comb compared to always @*
9.2.2.3	Latched logic always_latch procedure
9.2.2.4	Sequential logic always_ff procedure
9.2.3	Final procedures
9.3	Block statements
9.3.1	Sequential blocks
9.3.2	Parallel blocks
9.3.3	Statement block start and finish times
9.3.4	Block names
9.3.5	Statement labels
9.4	Procedural timing controls
9.4.1	Delay control
9.4.2	Event control
9.4.2.1	Event OR operator
9.4.2.2	Implicit event_expression list
9.4.2.3	Conditional event controls
9.4.2.4	Sequence events
9.4.3	Level-sensitive event control
9.4.4	Level-sensitive sequence controls
9.4.5	Intra-assignment timing controls
9.5	Process execution threads
9.6	Process control
9.6.1	Wait fork statement
9.6.2	Disable statement
9.6.3	Disable fork statement
9.7	Fine-grain process control
10.3	Continuous assignments
10.3.1	The net declaration assignment
10.3.2	The continuous assignment statement
10.3.3	Continuous assignment delays
10.3.4	Continuous assignment strengths
10.4.1	Blocking procedural assignments
10.4.2	Nonblocking procedural assignments
10.6.1	The assign and deassign procedural statements
10.6.2	The force and release procedural statements
11	Operators and expressions
11.1	General
11.2	Overview
11.2.1	Constant expressions
11.2.2	Aggregate expressions
11.3	Operators
11.3.1	Operators with real operands
11.3.2	Operator precedence
11.3.3	Using integer literals in expressions
11.3.4	Operations on logic (4-state) and bit (2-state) types
11.3.5	Operator expression short circuiting
11.3.6	Assignment within an expression
11.4	Operator descriptions
11.4.1	Assignment operators
11.4.2	Increment and decrement operators
11.4.3	Arithmetic operators
11.4.3.1	Arithmetic expressions with unsigned and signed types
11.4.4	Relational operators
11.4.5	Equality operators
11.4.6	Wildcard equality operators
11.4.7	Logical operators
11.4.8	Bitwise operators
11.4.9	Reduction operators
11.4.10	Shift operators
11.4.11	Conditional operator
11.4.12	Concatenation operators
11.4.12.1	Replication operator
11.4.12.2	String concatenation
11.4.13	Set membership operator
11.4.14	Streaming operators (pack/unpack)
11.4.14.1	Concatenation of stream_expressions
11.4.14.2	Re-ordering of the generic stream
11.4.14.3	Streaming concatenation as an assignment target (unpack)
11.4.14.4	Streaming dynamically sized data
11.5	Operands
11.5.1	Vector bit-select and part-select addressing
11.5.2	Array and memory addressing
11.5.3	Longest static prefix
11.6	Expression bit lengths
11.6.1	Rules for expression bit lengths
11.6.2	Example of expression bit-length problem
11.6.3	Example of self-determined expressions
11.7	Signed expressions
11.8	Expression evaluation rules
11.8.1	Rules for expression types
11.8.2	Steps for evaluating an expression
11.8.3	Steps for evaluating an assignment
11.8.4	Handling X and Z in signed expressions
11.9	Tagged union expressions and member access
11.10	String literal expressions
11.10.1	String literal operations
11.10.2	String literal value padding and potential problems
11.10.3	Empty string literal handling
11.11	Minimum, typical, and maximum delay expressions
11.12	Let construct
12	Procedural programming statements
12.1	General
12.2	Overview
12.3	Syntax
12.4	Conditional if-else statement
12.4.1	if-else-if construct
12.4.2	unique-if, unique0-if, and priority-if
12.4.2.1	Violation reports generated by unique-if, unique0-if, and priority-if constructs
12.4.2.2	If statement violation reports and multiple processes
12.5	Case statement
12.5.1	Case statement with do-not-cares
12.5.2	Constant expression in case statement
12.5.3	unique-case, unique0-case, and priority-case
12.5.3.1	Violation reports generated by unique-case, unique0-case, and priority-case constructs
12.5.3.2	Case statement violation reports and multiple processes
12.5.4	Set membership case statement
12.6	Pattern matching conditional statements
12.6.1	Pattern matching in case statements
12.6.2	Pattern matching in if statements
12.6.3	Pattern matching in conditional expressions
12.7	Loop statements
12.7.1	The for-loop
12.7.2	The repeat loop
12.7.3	The foreach-loop
12.7.4	The while-loop
12.7.5	The do...while-loop
12.7.6	The forever-loop
12.8	Jump statements
13.3	Tasks
13.3.1	Static and automatic tasks
13.4	Functions
13.4.1	Return values and void functions
13.4.2	Static and automatic functions
13.4.3	Constant functions
13.4.4	Background processes spawned by function calls
14.3	Clocking block declaration
15.4	Mailboxes
15.5	Named Events
16.2	Overview
16.4	Deferred assertions
16.7	Sequences
16.9	Sequence operations
16.10	Local variables
16.12	Declaring properties
16.14	Concurrent assertions
16.15	Disable iff resolution
16.17	Expect statement
18.4	Random variables
18.4.1	Rand modifier
18.4.2	Randc modifier
18.5	Constraint blocks
18.5.1	External constraint blocks
18.5.2	Constraint inheritance
18.5.3	Set membership
18.5.4	Distribution
18.5.5	Uniqueness constraints
18.5.6	Implication
18.5.7	if–else constraints
18.5.8	Iterative constraints
18.5.8.1	foreach iterative constraints
18.5.8.2	Array reduction iterative constraints
18.5.9	Global constraints
18.5.10	Variable ordering
18.5.11	Static constraint blocks
18.5.12	Functions in constraints
18.5.13	Constraint guards
18.5.14	Soft constraints
18.5.14.1	Soft constraint priorities
18.5.14.2	Discarding soft constraints
18.6	Randomization methods
18.6.1	Randomize()
18.6.2	Pre_randomize() and post_randomize()
18.6.3	Behavior of randomization methods
18.7	In-line constraints—randomize() with
18.7.1	local:: scope resolution
18.8	Disabling random variables with rand_mode()
18.9	Controlling constraints with constraint_mode()
18.10	Dynamic constraint modification
18.11	In-line random variable control
18.11.1	In-line constraint checker
18.12	Randomization of scope variables—std::randomize()
18.12.1	Adding constraints to scope variables—std::randomize() with
18.13	Random number system functions and methods
18.13.1	$urandom
18.13.2	$urandom_range()
18.13.3	srandom()
18.13.4	get_randstate()
18.13.5	set_randstate()
18.14	Random stability
18.14.1	Random stability properties
18.14.2	Thread stability
18.14.3	Object stability
18.15	Manually seeding randomize
18.16	Random weighted case—randcase
18.17	Random sequence generation—randsequence
18.17.1	Random production weights
18.17.2	if–else production statements
18.17.3	Case production statements
18.17.4	Repeat production statements
18.17.5	Interleaving productions—rand join
18.17.6	Aborting productions—break and return
18.17.7	Value passing between productions
20.2	Simulation control system tasks
20.3	Simulation time system functions
20.4	Timescale system tasks
20.5	Conversion functions
20.6	Data query functions
20.7	Array query functions
20.8	Math functions
20.9	Bit vector system functions
20.10	Severity tasks
20.11	Elaboration system tasks
20.13	Sampled value system functions
20.15	Probabilistic distribution functions
21.2	Display system tasks
21.3	File input/output system tasks and system functions
21.4	Loading memory array data from a file
21.6	Command line input
21.7	Value change dump (VCD) files
23.2	Module definitions
22	Compiler directives
22.1	General
22.2	Overview
22.3	resetall
22.4	include
22.5	define, undef and undefineall
22.5.1	define
22.5.2	undef
22.5.3	undefineall
22.6	ifdef, else, elsif, endif, ifndef
22.7	timescale
22.8	default_nettype
22.9	unconnected_drive and nounconnected_drive
22.10	celldefine and endcelldefine
22.11	pragma
22.12	line
22.13	__FILE__ and __LINE__
24.3	The program construct
25.3	Interface syntax
26.2	Package declarations
26.3	Referencing data in packages
